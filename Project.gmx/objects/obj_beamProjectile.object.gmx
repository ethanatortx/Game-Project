<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialize variables

// damage dealt per tick to player
damage = 0;

// position beam originates from (top left corner of beam)
posX = 0; // x position
posY = 0; // y position

// angle of beam
dir = 0;

// dimensions of beam (-1 limit is unbounded)

// starting length
length = 0;
// limit on length growth
lengthLimit = -1;
// spd of length growth
lSpd = 1;

// starting width
width = 0;
// limit on width growth
widthLimit = -1;
// speed of width
wSpd = 1;

// colours and alphas of beam

// color of the inside of the projected beam
insideColour = make_colour_rgb(255,255,255);
insideAlpha = 1; // alpha value of inside

// color of the edge of the projected beam
edgeColour = make_colour_rgb(0,0,0);
edgeAlpha = 1; // alpha value of edge of beam
edgeWidth = 1; // width of the bounding on the beam in pixels
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// modify beam and deal damage

// modify beam dimensions
event_user(0);

// deal damage to player
event_user(1);

sound_play(snd_ping);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// damage player

var invAngle = -1*dir;

transP = scrRotatePoint(invAngle, obj_player_main.x - posX, obj_player_main.y - posY);

if (point_in_rectangle(transP[0],transP[1],0,0,length,width)) {
    global.playerHealth -= scrDeltaApply(damage,true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// modify beam dimensions

// apply delta to length and witdth increments
var l = scrDeltaApply(lSpd,true);
var w = scrDeltaApply(wSpd,true);

// if resultant is less than limit, apply length increase
if (length + l &lt; lengthLimit || lengthLimit == -1) {
    length += l;
}

// if resultant is less than limit, apply width increase
if ((width + w &lt; widthLimit) || (widthLimit == -1)) {
    width += w;
}

// create list for creating non-transformed points
var pList = ds_list_create();

// add variables to the thing
for (i = 0; i &lt; 4; i++) {
    switch (i) {
        case 0: ds_list_insert(pList,i,0); ds_list_add(pList,0); break;
        case 1: ds_list_insert(pList,i,length); ds_list_add(pList,0); break;
        case 2: ds_list_insert(pList,i,length); ds_list_add(pList,width); break;
        case 3: ds_list_insert(pList,i,0); ds_list_add(pList,width); break;
    }
}

// transform rectangle
var transformed = scrRotatePolygon(dir,pList);

// take variables from the transformed thing
for (i = 0; i &lt; 4; i++) {
    switch (i) {
        case 0: p1[0] = ds_list_find_value(transformed,i); p1[1] = ds_list_find_value(transformed,i+4); break;
        case 1: p2[0] = ds_list_find_value(transformed,i); p2[1] = ds_list_find_value(transformed,i+4); break;
        case 2: p3[0] = ds_list_find_value(transformed,i); p3[1] = ds_list_find_value(transformed,i+4); break;
        case 3: p4[0] = ds_list_find_value(transformed,i); p4[1] = ds_list_find_value(transformed,i+4); break;
    }
}

ds_list_destroy(pList);
ds_list_destroy(transformed);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw modified rectangle as triangle strip primitive

// set counter for total amount of points
var steps = 4;
draw_primitive_begin(pr_trianglestrip);

draw_set_colour(insideColour);
draw_set_alpha(insideAlpha);

// add vertexes at point positions
for (i = 0; i &lt; steps; i++) {
    switch (i) {
        case 0: draw_vertex(posX+p1[0],posY+p1[1]); break;
        case 1: draw_vertex(posX+p2[0],posY+p2[1]); break;
        case 2: draw_vertex(posX+p4[0],posY+p4[1]); break;
        case 3: draw_vertex(posX+p3[0],posY+p3[1]); break;
    }
}

// end draw cycle and write inside
draw_primitive_end();

// drawing bounding box

// set colour and alpha to rectangle edge
draw_set_colour(edgeColour)
draw_set_alpha(edgeAlpha);
var sinW, cosW;
sinW = edgeWidth*dsin(dir);
cosW = edgeWidth*dcos(dir);

// multiple draw cycle iterator (o: outside, k: inside)
for (o = 0; o &lt; steps; o++) {

    // begin triangle strip primitive (repeated before each wall's draw cycles)
    draw_primitive_begin(pr_trianglestrip);
    for (k = 0; k &lt; 4; k++) {
        if (o == 0) {
            // draw top wall of bounding box
            switch (k){
                case 0: draw_vertex(posX+p1[0],posY+p1[1]); break;
                case 1: draw_vertex(posX+p2[0],posY+p2[1]); break;
                case 2: draw_vertex(posX+p1[0]+sinW,posY+p1[1]+cosW); break;
                case 3: draw_vertex(posX+p2[0]+sinW,posY+p2[1]+cosW); break; 
            }
        } else if (o == 1) {
            // draw right wall of bounding box
            switch (k){
                case 0: draw_vertex(posX+p2[0]+sinW,posY+p2[1]+cosW); break;
                case 1: draw_vertex(posX+p3[0]-sinW,posY+p3[1]-cosW); break;
                case 2: draw_vertex(posX+p2[0]+sinW-cosW,posY+p2[1]+cosW+sinW); break;
                case 3: draw_vertex(posX+p3[0]-sinW-cosW,posY+p3[1]-cosW+sinW); break;
            }
        } else if (o == 2) {
            // draw bottom wall of bounding box
            switch (k){
                case 0: draw_vertex(posX+p3[0],posY+p3[1]); break;
                case 1: draw_vertex(posX+p4[0],posY+p4[1]); break;
                case 2: draw_vertex(posX+p3[0]-sinW,posY+p3[1]-cosW); break;
                case 3: draw_vertex(posX+p4[0]-sinW,posX+p4[1]-cosW); break;
            }
        } else if (o == 3) {
            // draw left wall of bounding box
            switch (k){
                case 0: draw_vertex(posX+p1[0]+sinW,posY+p1[1]+cosW); break;
                case 1: draw_vertex(posX+p4[0]-sinW,posY+p4[1]-cosW); break;
                case 2: draw_vertex(posX+p1[0]+sinW+cosW,posX+p1[1]+cosW-sinW); break;
                case 3: draw_vertex(posX+p4[0]-sinW+cosW,posY+p4[1]-cosW-sinW); break;
            }
        }
    }
    // end primitive draw cycle (repeat after each vertex cycle ends)
    draw_primitive_end();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
