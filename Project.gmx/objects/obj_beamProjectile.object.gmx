<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialize variables

// damage dealt per tick to player
damage = 3;

// position beam originates from (top left corner of beam)
posX = 100; // x position
posY = 100; // y position

// angle of beam
dir = 90;

// dimensions of beam (-1 limit is unbounded)

// starting length
length = 0;
// limit on length growth
lengthLimit = -1;
// spd of length growth
lSpd = .2;

// starting width
width = 20;
// limit on width growth
widthLimit = 20;
// speed of width
wSpd = 0;

// colours and alphas of beam

// color of the inside of the projected beam
insideColour = make_colour_rgb(180,0,0);
insideAlpha = .5; // alpha value of inside

// color of the edge of the projected beam
edgeColour = make_colour_rgb(220,0,0);
edgeAlpha = .8; // alpha value of edge of beam
edgeWidth = 5; // width of the bounding on the beam in pixels
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// modify beam and deal damage

// modify beam dimensions
event_user(0);

// deal damage to player
event_user(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// damage player

var invAngle = -1*dir;

transP = scrRotatePoint(invAngle, obj_player_main.x - posX, obj_player_main.y - posY);

if (point_in_rectangle(transP[0],transP[1],0,0,length,width)) {
    global.playerHealth -= scrDeltaApply(damage,true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// modify beam dimensions

// apply delta to length and witdth increments
var l = scrDeltaApply(lSpd,true);
var w = scrDeltaApply(wSpd,true);

// if resultant is less than limit, apply length increase
if (length + l &lt; lengthLimit || lengthLimit == -1) {
    length += l;
}

// if resultant is less than limit, apply width increase
if ((width + w &lt; widthLimit) || (widthLimit == -1)) {
    width += w;
}

// create list for creating non-transformed points
var pList = ds_list_create();

// add variables to the thing
for (i = 0; i &lt; 4; i++) {
    switch (i) {
        case 0: ds_list_insert(pList,i,0); ds_list_add(pList,0); break;
        case 1: ds_list_insert(pList,i,length); ds_list_add(pList,0); break;
        case 2: ds_list_insert(pList,i,length); ds_list_add(pList,width); break;
        case 3: ds_list_insert(pList,i,0); ds_list_add(pList,width); break;
    }
}

// transform rectangle
var transformed = scrRotatePolygon(dir,pList);

// take variables from the transformed thing
for (i = 0; i &lt; 4; i++) {
    switch (i) {
        case 0: p1[0] = ds_list_find_value(transformed,i); p1[1] = ds_list_find_value(transformed,i+4); break;
        case 1: p2[0] = ds_list_find_value(transformed,i); p2[1] = ds_list_find_value(transformed,i+4); break;
        case 2: p3[0] = ds_list_find_value(transformed,i); p3[1] = ds_list_find_value(transformed,i+4); break;
        case 3: p4[0] = ds_list_find_value(transformed,i); p4[1] = ds_list_find_value(transformed,i+4); break;
    }
}

ds_list_destroy(pList);
ds_list_destroy(transformed);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug
draw_text(0,0,floor(p1[0]));
draw_text(30,0,floor(p1[1]));
draw_text(0,10,floor(p2[0]));
draw_text(30,10,floor(p2[1]));
draw_text(0,20,floor(p3[0]));
draw_text(30,20,floor(p3[1]));
draw_text(0,30,floor(p4[0]));
draw_text(30,30,floor(p4[1]));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw modified rectangle as triangle strip primitive

// set counter for total amount of points
var steps = 4;
draw_primitive_begin(pr_trianglestrip);

draw_set_colour(insideColour);
draw_set_alpha(insideAlpha);

// add vertexes at point positions
for (i = 0; i &lt; steps; i++) {
    switch (i) {
        case 0: draw_vertex(posX+p1[0],posY+p1[1]); break;
        case 1: draw_vertex(posX+p2[0],posY+p2[1]); break;
        case 2: draw_vertex(posX+p4[0],posY+p4[1]); break;
        case 3: draw_vertex(posX+p3[0],posY+p3[1]); break;
    }
}

// end draw cycle and write inside
draw_primitive_end();

// begin draw for edges
draw_primitive_begin(pr_trianglestrip);

// drawing bounding box
draw_set_colour(edgeColour)
draw_set_alpha(edgeAlpha);
for (o = 0; o &lt; 4; o++) {
    for (k = 0; k &lt; 4; k++) {
        if (o == 0) {
            switch (k){
                case 0: draw_vertex(posX+p1[0],posY+p1[1]);
                case 1: draw_vertex(posX+p2[0],posY+p2[1]);
                case 2: draw_vertex(posX+p1[0],posY+p1[1]-edgeWidth);
                case 3: draw_vertex(posX+p2[0],posY+p2[1]-edgeWidth);
            }
        } /*else if (o == 1) {
            switch (k){
                case 0: draw_vertex(posX+p2[0],posY+p2[1]+edgeWidth);
                case 1: draw_vertex(posX+p3[0],posY+p3[1]-edgeWidth);
                case 2: draw_vertex(posX+p2[0]-edgeWidth,posY+p2[1]+edgeWidth);
                case 3: draw_vertex(posX+p3[0]-edgeWidth,posY+p3[1]-edgeWidth);
            }
        } else if (o == 2) {
            switch (k){
                case 0: draw_vertex(posX+p4[0],posY+p4[1]-edgeWidth);
                case 1: draw_vertex(posX+p3[0],posY+p3[1]-edgeWidth);
                case 2: draw_vertex(posX+p4[0],posY+p4[1]);
                case 3: draw_vertex(posX+p3[0],posY+p3[1]);
            }
        } else if (o == 3) {
            switch (k){
                case 0: draw_vertex(posX+p1[0],posY+p1[1]+edgeWidth);
                case 1: draw_vertex(posX+p1[0]+edgeWidth,posY+p1[1]+edgeWidth);
                case 2: draw_vertex(posX+p4[0],posY+p4[1]-edgeWidth);
                case 3: draw_vertex(posX+p4[0]+edgeWidth,posY+p4[1]-edgeWidth);
            }
        }*/
    }
}

draw_primitive_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
