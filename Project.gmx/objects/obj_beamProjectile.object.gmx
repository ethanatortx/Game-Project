<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialize variables

// damage dealt per tick to player
damage = 0;

// position beam originates from (top left corner of beam)
posX = 100; // x position
posY = 100; // y position

// angle of beam
dir = 30;

// dimensions of beam (-1 limit is unbounded)

// starting length
length = 0;
// limit on length growth
lengthLimit = -1;
// spd of length growth
lSpd = .2;

// starting width
width = 20;
// limit on width growth
widthLimit = 20;
// speed of width
wSpd = 0;

// colours and alphas of beam

// color of the inside of the projected beam
colorInside = make_colour_rgb(180,0,0);
alphaInside = .5; // alpha value of inside

// color of the edge of the projected beam
colorEdge = make_colour_rgb(220,0,0);
alphaEdge = .8; // alpha value of edge of beam
edgeWidth = 5; // width of the bounding on the beam in pixels
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// modify beam and deal damage

// modify beam dimensions
event_user(0);

// deal damage to player
event_user(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// damage player


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// modify beam dimensions

// apply delta to length and witdth increments
var l = scrDeltaApply(lSpd,true);
var w = scrDeltaApply(wSpd,true);

// if resultant is less than limit, apply length increase
if (length + l &lt; lengthLimit || lengthLimit == -1) {
    length += l;
}

// if resultant is less than limit, apply width increase
if ((width + w &lt; widthLimit) || (widthLimit == -1)) {
    width += w;
}

var pGrid = scrRotateRectangle(dir,length,width);

for (o = 0; o &lt; ds_grid_height(pGrid); o++) {
    for (i = 0; i &lt; ds_grid_width(pGrid); i++) {
        switch (o) {
            case 0: p1[i] = ds_grid_get(pGrid,i,o); break;
            case 1: p2[i] = ds_grid_get(pGrid,i,o); break;
            case 2: p3[i] = ds_grid_get(pGrid,i,o); break;
            case 3: p4[i] = ds_grid_get(pGrid,i,o); break;
        }
    }
}

ds_grid_destroy(pGrid);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug
draw_text(0,0,floor(p1[0]));
draw_text(30,0,floor(p1[1]));
draw_text(0,10,floor(p2[0]));
draw_text(30,10,floor(p2[1]));
draw_text(0,20,floor(p3[0]));
draw_text(30,20,floor(p3[1]));
draw_text(0,30,floor(p4[0]));
draw_text(30,30,floor(p4[1]));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw modified rectangle as triangle strip primitive

// set counter for total amount of points
var steps = 4;
draw_primitive_begin(pr_trianglestrip);

// add vertexes at point positions
for (i = 0; i &lt; steps; i++) {
    switch (i) {
        case 0: draw_vertex_colour(posX+p1[0],posY+p1[1],colorInside,alphaInside); break;
        case 1: draw_vertex_colour(posX+p2[0],posY+p2[1],colorInside,alphaInside); break;
        case 2: draw_vertex_colour(posX+p4[0],posY+p4[1],colorInside,alphaInside); break;
        case 3: draw_vertex_colour(posX+p3[0],posY+p3[1],colorInside,alphaInside); break;
    }
}

// end draw cycle and write to GPU
draw_primitive_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
