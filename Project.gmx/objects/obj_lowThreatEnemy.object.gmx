<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_lowThreatEnemy</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>self</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// create detection box

// calibrate detection variables
// constants
detRadius = 50;
detDelay = 20;
attackRadius = 50;
attackDelay = 5;


// modifiables
detCounter = detDelay;
attackCounter = attackDelay;
activated = false;
attacking = false;

// attacking constants

swingOffset = 0;
swingRange = 50;
swingSpeed = 1;
swingArcMax = .3 // percentage of swing circumference (0 -&gt; 1)
swingArcMax *= pi*2*swingRange;
swingDamage = 5;

// attacking modifiables
swingArc = 0;
angleSnapshot = 0;
within = false;
list = 0;

// calibrate variables for detecting player and attacking them
playerX = objPlayerMain.x;
playerY = objPlayerMain.y;

var xDif = playerX-x;
var yDif = playerY-y;

// set initial vector between this object and palyer
distToPlayer = sqrt(sqr(xDif)+sqr(yDif));
angleWithPlayer = darctan(xDif/yDif);

// speed constants
hspd = scrDeltaApply(.2,true);
vspd = scrDeltaApply(.2,true);

draw = false;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// check detection

// check if already activated
if (!activated) {
    // check collision of player with detection radius
    if (detCounter &lt;= 0) { // check if countdown has reached zero yet in order to activate enemy
        activated = true; 
    } else if (point_in_circle(playerX,playerY,x,y,detRadius)) {
        // iterate down the counter until player is detected
        detCounter -= global.delta;
    } else {
        // reset counter if player goes outside collision detecter
        detCounter = detDelay;
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// update vector to player

// update player poisition
playerX = objPlayerMain.x;
playerY = objPlayerMain.y;

var xDif = playerX-x;
var yDif = playerY-y;

// set initial vector between this object and palyer
distToPlayer = sqrt(sqr(xDif)+sqr(yDif));
angleWithPlayer = scrCorrectAngle(x,y,playerX,playerY);


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// move enemy towards player if activated

if (activated) {
    direction = angleWithPlayer;
    speed = sqrt(sqr(hspd)+sqr(vspd));
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// check whether player is within attack trigger radius
if (activated) {
    if (!attacking) {
        if (attackCounter &lt;= 0) {    
            attacking = true;
            angleSnapshot = angleWithPlayer
            attackCounter = attackDelay;
        } else if (point_in_circle(playerX,playerY,x,y,attackRadius)) {
            attackCounter -= global.delta;
        } else {
            attackCounter = attackDelay;
        }
    } else if (attacking) {
        event_user(0);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// calculate swing attack and check whether player is within swing radius
swingSpeed *= global.delta;
if (swingArc &lt; swingArcMax) {
    
    swingArc += swingSpeed;
    within = scrAttackSwing(x,y,playerX,playerY,swingOffset+angleSnapshot,swingArc,swingRange);
    draw = true;

} else {
    attacking = false;
    swingArc = 0;
}

swingSpeed /= global.delta;

if (within) {
    global.playerHealth -= swingDamage;
    attacking = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug

draw_text(0,0,angleWithPlayer);
draw_text(0,20,distToPlayer);
draw_text(0,40,activated);
draw_text(0,60,detCounter);
draw_text(0,80,global.playerHealth);
draw_text(0,100,within);
if (draw) {
    if (ds_exists(list,ds_type_list)) {
        draw_text(40,100,scrPointInPolygon(playerX,playerY,list));
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw debug radius stuff

// draw detection radius
draw_circle_colour(x,y,detRadius,make_colour_rgb(255,0,0),make_colour_rgb(255,0,0),true);

// draw attack trigger radius
draw_circle_colour(x,y,attackRadius,make_colour_rgb(0,255,0),make_colour_rgb(0,255,0),true);


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

if (draw) {
    if (attacking) {
        if (ds_exists(list,ds_type_list)) {
            draw_primitive_begin(pr_trianglestrip);
            for (i = 0; i &lt; ds_list_size(list)/2; i++) {
                switch (i) {
                    case 0: draw_vertex(ds_list_find_value(list,0),ds_list_find_value(list,0+ds_list_size(list)/2));
                    case 1: draw_vertex(ds_list_find_value(list,1),ds_list_find_value(list,1+ds_list_size(list)/2));
                    case 2: draw_vertex(ds_list_find_value(list,3),ds_list_find_value(list,3+ds_list_size(list)/2));
                    case 3: draw_vertex(ds_list_find_value(list,2),ds_list_find_value(list,2+ds_list_size(list)/2));
                }
            }
            draw_primitive_end();
            ds_list_destroy(list);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
